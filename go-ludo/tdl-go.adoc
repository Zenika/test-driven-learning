= TDL Go

:toc:
:toc-placement!:
:icons: font

:golang-uri: https://golang.org
:golang-doc-uri: {golang-uri}/doc
:golang-blog: https://blog.golang.org
:github-uri: https://github.com
:golang-github: {github-uri}/golang

.Sommaire
toc::[]

== Introduction

Go est un language qui buzz beaucoup depuis quelques temps, j'ai donc eut l'envie de m'initier à ce langage.

Je suis demandé comment commencer : faire des tutoriels, souvent cela se résume à des copier-coller et finit par une connaissance très partielle.

Du coup, je suis dit pourquoi ne pas essayer de faire le kata FizzBuzz pour apprendre.

C'est un kata très simple que je connais bien, je l'ai fait avec différentes contraintes en Java alors pourquoi ne pas le faire en Go ?

C'est parti !


== Point de départ

Le site officiel de Go : {golang-uri}.

Pour commencer, j'ai installé Go.
C'est plutôt simple, tout se trouve à cette adresse suivante : {golang-uri}/dl.

Après il me fallait un minimum de documentation sur le langage.
N'étant pas un grand fan de StackOverflow, j'aime les sites contenant la documentation et les samples officiels.

J'ai trouvé 4 points d'entrées qui m'ont semblé pertinent :

- {golang-doc-uri}
- {golang-doc-uri}/effective_go.html
- {golang-doc-uri}/code.html
- {golang-uri}/ref/spec
- {github-uri}/golang/go/wiki


== La structure

La question de base pour commencer correctement avec un langage c'est la structure d'un projet. Pour Go, il a été facile de trouver cela sur le officiel : {golang-doc-uri}/code.html

....
<GOPATH>
├── bin/
│   ├── hello                          # command executable
│   └── outyet                         # command executable
├── pkg/
│   └── linux_amd64/
│       └── github.com/golang/example/
│           └── stringutil.a           # package object
└── src/
    ├── github.com/golang/example/
    │   └── .git/                      # Git repository metadata
    ├── hello/
    │   └── hello.go                   # command source
    ├── outyet/
    │   ├── main.go                    # command source
    │   └── main_test.go               # test source
    └── stringutil/
        ├── reverse.go                 # package source
        └── reverse_test.go            # test source
....

Normalement lors de l'installation la variable d'environnement `GOROOT`, pointant vers les binaires de Go a du être crée.

IMPORTANT: En plus de `GOROOT`, il faut définir la variable d'environnement `GOPATH` qui doit pointer vers la racine du workspace du projet (cf stucture ci-dessus).
Plus d'informations : https://golang.org/doc/code.html#GOPATH


J'ai créé uniquement la structure suivante :

....
goworkspace
├── bin/
├── pkg/
└── src/
    └── fizzbuzz/
....

== Les tests

Après cela il me fallait comprendre comment fonctionnait les tests avec Go.

Je ne voulais pas rentrer trop dans le langage tant que je savais pas comment faire un test.

Une petite fouille sur le site de Go et le dépôt GitHub officiels et hop :

- {golang-github}/go/wiki/LearnTesting
- {golang-blog}/examples
- {github-uri}/golang-samples/testing
- {golang-uri}/pkg/testing

Un point important dans Go est le fonctionnement de sa bibliothèque de tests :

[quote, '{golang-doc-uri}/faq#assertions']
_____
Why does Go not have assertions?

Go doesn't provide assertions.
They are undeniably convenient, but our experience has been that programmers use them as a crutch to avoid thinking about proper error handling and reporting.
Proper error handling means that servers continue operation after non-fatal errors instead of crashing.
Proper error reporting means that errors are direct and to the point, saving the programmer from interpreting a large crash trace.
Precise errors are particularly important when the programmer seeing the errors is not familiar with the code.

We understand that this is a point of contention.
There are many things in the Go language and libraries that differ from modern practices, simply because we feel it's sometimes worth trying a different approach.
_____

Il n'y a donc pas d'assertions de base dans Go mais juste un structure permettant d'enregister les erreurs.

J'ai trouvé cela dans la documentation de Go :

.{golang-doc-uri}/code.html#Testing
[source, go]
----
package stringutil

import "testing" <1>

func TestReverse(t *testing.T) { <2>

  for _, c := range []struct {
    in, want string
  }{
    {"Hello, world", "dlrow, olleH"},
    {"Hello, 世界", "界世, olleH"},
    {"", ""},
  } {
    got := Reverse(c.in)
    if got != c.want {
      t.Errorf("Reverse(%q) == %q, want %q", c.in, got, c.want) <3>
    }
  }
}
----
<1> importation de la bibliothèque de tests
<2> paramètre de la méthode pour accéder au framework de tests
<3> émission d'une erreur (echec du test)

Dans la documentation il est aussi dit que les fichiers de tests doivent se terminer par `_test.go` et que chaque méthode de test doit avoir la forme `TestXXX`.

Voilà je me sens prét à commencer.
Je ne connais pas encore le langage mais je sais comment ecrire un test !


== IDE

Pour pouvoir écrire un code, un bon outil c'est important.

Donc je suis parti à la recherche d'un IDE pour Go.

Premier test avec mes IDE habituels, ca oui j'utilise plusieurs IDE.

Donc j'ouvre Brackets, IntelliJ et Eclipse à la recherche du support langage.

Je ne trouve rien de très pertinent.

Je suppose que VIM doit avoir un support mais n'étant pas un grand habitué de cet éditeur je décide continuer à chercher.

Je me retrouve sur le site officiel puis le GitHub et je trouve cette page :

- {golang-github}/go/wiki/IDEsAndTextEditorPlugins

Je décide donc de tester https://github.com/visualfc/liteide[LiteIDE].
Super autocomplétion des libraries, le style de l'IDE est moche mais bon si va bien c'est OK.
Mais *fail* car le support du clavier est destiné uniquement au clavier QWERTY.

Donc c'est reparti pour tester un nouvel IDE.

J'avais déjà https://atom.io[Atom] d'installé donc je regarde les plugins disponible et supprise :

- {atom-package-uri}/language-go[language-go]
- {atom-package-uri}/go-plus[go-plus] : `apm install go-plus`

`language-go` permet le support de la coloration syntaxique de Go.

`go-plus` permet d'avoir de l'autocomplétion, le formatteur officiel, du linting et donne un retour visuel des erreurs de syntaxe. Un super plugin !

`go-plus` necessite l'installation de {github-uri}/nsf/gocode[Gocode] pour l'autocompletion.

J'ai donc arreté mon choix sur Atom.


== Le langage

Maintenant, il faut mettre les mains dans cambouis !

Les commentaires sont assez clasiques : `// mon commentaire` et `/* mon commentaire */`

Après quelques lectures de la documentation et de quelques samples, je comprends que dans Go est principalement un language fonctionnel où les fonctions sont simplement exposée par le package.

J'ai décidé de créer un premier fichier `fizzbuzz.go`.

A l'aide de la documentation j'ai créé ceci :

.fizzbuzz.go
[source, go]
----
package kata

import "fmt"

// FizzBuzz main function
func FizzBuzz() {
  fmt.Println("Kata FizzBuzz")
}
----

C'est un fichier simple qui affiche `Kata FizzBuzz` dans la console.

Je tente :

[source, shell]
----
go run fizzbuzz.go
----

Mais cela ne marche pas :

....
go run: cannot run non-main package
....

Ok j'ai fait n'importe quoi en voulant lancer ce fichier.
Pour que cela marche j'aurais du définir le package de mon fichier comme étant `main` et créer une fonction nommé `main` :

.fizzbuz.go
[source, go]
----
package main

import "fmt"

// FizzBuzz main function
func main() {
  fmt.Println("Kata FizzBuzz")
}
----

Mais mon premier objectif n'était pas de faire tourner une ligne de commande mais des tests afin de pouvoir faire le kata.

J'ai donc gardé le premier contenu du fichier `fizzbuzz.go` et créé nouveau fichier `fizzbuzz_test.go`

Pour cela, il me faut déclarer des variables, je regarde les sources examples du GitHub officiel.

Je comprends que les variables sont déclarées sous la forme :

[source, go]
----
var foo string
----

Et qu'il est possible, lors d'une déclaration avec assignation, utiliser une notation réduite :

[source, go]
----
foo := "bar"
----
- pas besoin de `var`
- pas besoin de définir le type

J'écris donc mon premier test.

.fizzbuz_test.go
[source, go]
----
package kata

import "testing"

func Test_Should_TODO(t *testing.T) {

  FizzBuzz()

  actual := "0"
  expected := "1"

  if actual != expected {
    t.Errorf("Expected %s but was %s", expected, actual)
  }
}
----

J'ai simplement appelé la fonction `FizzBuzz` dans le test  et lancé le test :

[source, shell]
----
go test
----

Et la sortie de console était plutôt positive :

- mon message `Kata FizzBuzz` s'affichait bien
- mon test échouait ce qui était mon objectif.


....
Kata FizzBuzz
--- FAIL: Test_Should_TODO (0.00s)
        fizzbuzz_test.go:13: Expected 1 but was 0
FAIL
exit status 1
FAIL    /mysources/kata/fizz-buzz/go        0.084s
....

J'ai une idée très partielle du langage mais c'est parti pour le kata.


== Le kata

Mon objectif est bien sur de faire ce kata en TDD avec des *baby steps*.

=== Step 1

Je connais bien ce kata donc je commence par écrire un test simple pour écrire un chiffre dans la console.

.fizzbuz_test.go
[source, go]
----
package kata

import "testing"

func Test_should_print_string_representation_when_passing_an_integer(t *testing.T) {

    rt := Display(1)

    expected := "1"
    if rt != expected {
        t.Errorf("Must display %s but display %s", expected, rt)
    }
}
----

Voilà le test est écrit mais il est rouge : la function `Display` n'existe pas.

Pour créer cette méthode je dois pouvoir passer un paramètre à une fonction et convertir un `int` et `string`.

Encore une retour à la documentation.

La déclaration d'un paramètre d'une fonction se fait en écrivant le nom du paramètre puis son type.
Il possible de définir le type de retour en ajout le type après la déclaration de la méthode.

[source, go]
----
func Foo(bar int) string {
  // ...
}
----

Le deuxième point plus compliqué car je ne vois pas comment convertir un `int` en `string`.

Je ne trouve rien rapidement dans la documentation donc Google est mon ami.

Ce n'est pas très intuitif car il faut importer le package `strconv` et utiliser la méthode `strconv.Itoa()`.

Je créer la méthode `Display` dans `fizzbuz.go`.

.fizzbuz.go
[source, go]
----
package kata

import "fmt"
import (
    "fmt"
    "strconv"
)

// FizzBuzz main function
func FizzBuzz() {
    fmt.Println("Kata FizzBuzz")
}

// Display number
func Display(number int) string {
    return strconv.Itoa(number)
}
----

Je lance les tests (`go test`) et c'est bon mon test est vert, victoire !


=== Step 2

Bon maintenant, je vais devoir ajouter un nouveau test pour afficher `Fizz` lorsque le chiffre est `3`.

Ecrire le test est assez simple.

.fizzbuz_test.go
[source, go]
----
// Pour les multiples de trois afficher "Fizz".
func Test_should_print_Fizz_when_passing_3(t *testing.T) {

    rt := Display(3)

    if rt != "Fizz" {
        t.Errorf("Must display %s but return is %s", "Fizz", rt)
    }
}
----

Je créer un code stupide mais qui fait passer le test.

Pour cela j'ai besoin d'écrire un `if`, je l'ai déjà fait plus haut mais en copiant du code.

Je comprends en écrivant cette partie que les parenthèses sont optionnelles. Le formateur de Go les supprime automatiquement.

.fizzbuz.go
[source, go]
----
// Display number
func Display(number int) string {

    if number == 3
        return 3
    return strconv.Itoa(number)
}
----

Les accolades pour les `if` sont optionnelles, pour l'instant je n'en met pas (je ne suis pas fan du code inline ou sans accolades, je trouve que cela manque de lisibilité et augmente le risque d'erreur lors des évolutions).


Je relance les tests (`go test`) et ce test est vert, encore une victoire !


=== Step 3



== Et après ?
