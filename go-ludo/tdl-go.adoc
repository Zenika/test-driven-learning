= TDL Go
:toc:
:toc-placement!:
:icons: font

:golang-uri: https://golang.org
:golang-doc-uri: {golang-uri}/doc
:github-uri: https://github.com

.Sommaire
toc::[]


== Introduction

Go est un language qui buzz beaucoup depuis quelques temps, j'ai donc eut l'envie de m'initier à ce langage.

Je suis demandé comment commencer : faire des tutoriels, souvent cela se résume à des copier-coller et finit par une connaissance très partielle.

Du coup, je suis dit pourquoi ne pas essayer de faire le kata FizzBuzz pour apprendre.

C'est un kata très simple que je connais bien, je l'ai fait avec différentes contraintes en Java alors pourquoi ne pas le faire en Go ?

C'est parti !


== Point de départ

Le site officiel de Go : {golang-uri}.

Pour commencer, j'ai installé Go.
C'est plutôt simple, tout se trouve à cette adresse suivante : {golang-uri}/dl.

Après il me fallait un minimum de documentation sur le langage.
N'étant pas un grand fan de StackOverflow, j'aime les sites contenant la documentation et les samples officiels.

J'ai trouvé 4 points d'entrées qui m'ont semblé pertinent :

- {golang-doc-uri}
- {golang-doc-uri}/effective_go.html
- {golang-uri}/ref/spec
- {github-uri}/golang/go/wiki


== La structure

La question de base pour commencer correctement avec un langage c'est la structure d'un projet. Pour Go, il a été facile de trouver cela sur le officiel : {golang-doc-uri}/code.html

....
├── bin/
│   ├── hello                          # command executable
│   └── outyet                         # command executable
├── pkg/
│   └── linux_amd64/
│       └── github.com/golang/example/
│           └── stringutil.a           # package object
└── src/
    ├── github.com/golang/example/
    │   └── .git/                      # Git repository metadata
    ├── hello/
    │   └── hello.go                   # command source
    ├── outyet/
    │   ├── main.go                    # command source
    │   └── main_test.go               # test source
    └── stringutil/
        ├── reverse.go                 # package source
        └── reverse_test.go            # test source
....

IMPORTANT: TODO  GOROOT / GOPATH


== Les tests

Après cela il me fallait comprendre comment fonctionnait les tests avec Go.

Je ne voulais pas rentrer trop dans le langage tant que je savais pas comment faire un test.

Une petite fouille sur le site de Go et le dépôt GitHub officiels et hop :

- {github-uri}/golang/go/wiki/LearnTesting
- https://blog.golang.org/examples
- {github-uri}/golang-samples/testing
- {golang-uri}/pkg/testing

Un point important dans Go est le fonctionnement de sa bibliothèque de tests :

[quote, '{golang-doc-uri}/faq#assertions']
_____
Why does Go not have assertions?

Go doesn't provide assertions.
They are undeniably convenient, but our experience has been that programmers use them as a crutch to avoid thinking about proper error handling and reporting.
Proper error handling means that servers continue operation after non-fatal errors instead of crashing.
Proper error reporting means that errors are direct and to the point, saving the programmer from interpreting a large crash trace.
Precise errors are particularly important when the programmer seeing the errors is not familiar with the code.

We understand that this is a point of contention.
There are many things in the Go language and libraries that differ from modern practices, simply because we feel it's sometimes worth trying a different approach.
_____

Il n'y a donc pas d'assertions de base dans Go mais juste un structure permettant d'enregister les erreurs.

J'ai trouvé cela dans la documentation de Go :

.http://golang.org/doc/code.html#Testing
[source, go]
----
package stringutil

import "testing" <1>

func TestReverse(t *testing.T) { <2>

  for _, c := range []struct {
    in, want string
  }{
    {"Hello, world", "dlrow, olleH"},
    {"Hello, 世界", "界世, olleH"},
    {"", ""},
  } {
    got := Reverse(c.in)
    if got != c.want {
      t.Errorf("Reverse(%q) == %q, want %q", c.in, got, c.want) <3>
    }
  }
}
----
<1> importation de la bibliothèque de tests
<2> paramètre de la méthode pour accéder au framework de tests
<3> émission d'une erreur (echec du test)

Dans la documentation il est aussi dir que les fichiers de tests doivent se terminer par `_test.go` et que chaque méthode de test doit avoir la forme `TestXXX`.

Voilà je me sens prét à commencer. Je ne connais pas encore le langage mais je sais comment ecrire un test !


== IDE

Pour pouvoir écrire un code, un bon outil c'est important.

Donc je suis parti à la recherche d'un IDE pour Go.

Premier test avec mes IDE habituels, ca oui j'utilise plusieurs IDE.

Donc j'ouvre Brackets, IntelliJ et Eclipse à la recherche du support langage.

Je ne trouve rien de très pertinent.

Je suppose que VIM doit avoir un support mais n'étant pas un grand habitué de cet éditeur je décide continuer à chercher.

Je me retrouve sur le site officiel puis le GitHub et je trouve cette page :

- https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins

Je décide donc de tester https://github.com/visualfc/liteide[LiteIDE].
Super autocomplétion des libraries, le style de l'IDE est moche mais bon si va bien c'est OK.
Mais *fail* car le support du clavier est destiné uniquement au clavier QWERTY.

Donc c'est reparti pour tester un nouvel IDE.

J'avais déjà https://atom.io[Atom] d'installé donc je regarde les plugins disponible et supprise :

- {atom-package-uri}/language-go[language-go]
- {atom-package-uri}/go-plus[go-plus] : `apm install go-plus`

`language-go` permet le support de la coloration syntaxique de Go.

`go-plus` permet d'avoir de l'autocomplétion, le formatteur officiel, du linting et donne un retour visuel des erreurs de syntaxe. Un super plugin !

`go-plus` necessite l'installation de {github-uri}/nsf/gocode[Gocode] pour l'autocompletion.

J'ai donc arreté mon choix sur Atom.


== Le langage


== Le kata


== Et après ?
